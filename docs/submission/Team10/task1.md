# 第一阶段-跳棋底层逻辑实现
>## 1.已实现成果
>* 基础图形
>* 两人，四人，六人跳棋本地对战
>* 基础跳棋逻辑（行棋，判断行棋条件，回合交接）
>* 胜利判断

>## 2.实现方式
>1. 棋子的创建  
首先建立一个自定义`mybutton`类，继承`QPushbutton`类，每个`mybutton`即为跳棋中棋子可落点，如果该点处有棋子，则将该`mybutton`绘制相应颜色即可。该类具有一系列变量，如int 型的`color`(颜色参数)，`x0`与`y0`（原直角坐标系坐标），`j`（判断该位置上是否有棋子）等，float 型的`x`和`y`（在`mywidge`t上的坐标参数）。
>2. 棋盘的实现  
建立自定义窗口类`mywidget`,继承QWidget类。该类包括`mybutton`的18*18的二维数组，运用高等代数的坐标变换知识将需要的`mybutton`部署在mywidget的ui上，不需要的隐藏即可。以上操作均有mywidget类的成员函数`start()`在程序开始时执行。
>3. 行棋逻辑  
每点击一个`mybutton`（不论该点有无棋子),都会发送一个自定义信号，将该点的x0和y0属性传递至mywidget，并利用两个int型全局变量a和b保存，再点击下一个mybutton，如果上次点击无棋子，则重置全局变量a、b；如果上一次点击处有棋子，则进入行棋合法性判断函数`check（int，int）`,如果行棋合法，则进入跳跃函数`jump(int,int)`，实现棋子跳跃。
>4. 回合交接  
不同游戏模式设置不同的int型全局变量`form`,再设置一个全局变量`round`，初始化为1。每次执行`jump`函数后，`round`加一，每个`round`对应一个阵营，每次行棋时只有对应此时`round`的阵营可以行棋。以此实现简单的回合交接。

>## 3.待实现功能
>1. 联机功能
>2. 托管功能（AI)
>3. 贴图美化界面
  