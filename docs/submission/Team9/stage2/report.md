# Group 9 程设第二阶段作业报告

第二阶段，本组已经完成大部分用户界面与网络相关的操作，并且已经完成了支持多房间的准备工作。

## 小组分工

潘俊达在本阶段负责棋盘的接口优化和开发以及信号处理。
贾昊霖在本阶段负责网络连接，窗体UI设计和信号处理。

## 代码框架

### 整体框架

![](image/show.png)

### 网络连接：客户端

我们选择在客户端创建时立即在内存空间申请一个 `NetworkSocket`，连接完成之后，在客户端关闭之前都将保持该 `NetworkSocket` 的连接。换言之，套接字生命周期与客户端生命周期保持一致。

通过在不同窗口之间传递 NetworkSocket，我们保证了多个窗口都可以收到 server 发出的数据；通过 `connect` 和 `disconnect`，我们确保所有数据在同一时间会且只会有一个窗口作出响应。

![](image/server_client.png)

### 网络连接：服务端

在服务端处理上，我们选择了可拓展性比较强的一种写法：在`ServerWidget` 中维护一个 `std::vector<Room> roomList` 存储当前所有房间；接收消息之后找到对应房间再进行后续操作。这种写法的巨大优势在于我们只需要改**非常少**的代码就可以完美拓展到多房间，缺点是效率较低。

后续可能会改变房间和玩家检索算法（如使用哈希），不过考虑到实际需求该优化有可能不会实装。

### 信号处理

在服务端上，我们选择了**服务端接收-棋盘处理-服务端发射**的运作方式，服务端通过调用函数向棋盘传递信息，棋盘则通过发射信号告知服务器相关操作的结果或间接发送数据。

在客户端处，情况有所不同：由于客户端中有图形显示需求，将套接字转交给战局界面显然更为方便，因此我们选择的运作方式是**转交socket**，让 widget 对信号进行处理。

![](image/2Clients_running.png)

## 问题&解决/构想

1. 远程联机

目前正在尝试使用内网穿透：显然，这个方案最诱人之处在于一旦成功是可以实现远程联机的。

2. 多窗口的网络交接

最开始计划仅传递 `QTcpSocket`，但随后的实践中我们意识到如果创建新的 `NetworkSocket` 服务器并不知晓，会错将新的连接视作新用户而出错，因此最后选择了传递 `NetworkSocket`。

3. 实现上的小失误

位置分配的时候选择了最简单的`A B C D E F`再发送其切片，但很显然这是不正确的：正确的发送应当为`A D` / `A C E` / `B C E F` / `A B C D E F`。后续会在开发和完善中加以纠正。

## 说明

本组有意向参与第三阶段服务端的编写。（实际上，本组在第二阶段的程序已经基本可以完成多等待房间的维护，暂时未完成多战局的维护）

